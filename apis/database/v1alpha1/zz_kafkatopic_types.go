/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigInitParameters struct {

	// The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
	// This may be one of "delete", "compact", or "compact_delete".
	CleanupPolicy *string `json:"cleanupPolicy,omitempty" tf:"cleanup_policy,omitempty"`

	// The topic compression codecs used for a given topic.
	// This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
	CompressionType *string `json:"compressionType,omitempty" tf:"compression_type,omitempty"`

	// The amount of time, in ms, that deleted records are retained.
	DeleteRetentionMs *string `json:"deleteRetentionMs,omitempty" tf:"delete_retention_ms,omitempty"`

	// The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
	FileDeleteDelayMs *string `json:"fileDeleteDelayMs,omitempty" tf:"file_delete_delay_ms,omitempty"`

	// The number of messages accumulated on a topic partition before they are flushed to disk.
	FlushMessages *string `json:"flushMessages,omitempty" tf:"flush_messages,omitempty"`

	// The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
	FlushMs *string `json:"flushMs,omitempty" tf:"flush_ms,omitempty"`

	// The interval, in bytes, in which entries are added to the offset index.
	IndexIntervalBytes *string `json:"indexIntervalBytes,omitempty" tf:"index_interval_bytes,omitempty"`

	// The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the compression_type is set to "uncompressed" or it is set to producer and the producer is not using compression.
	MaxCompactionLagMs *string `json:"maxCompactionLagMs,omitempty" tf:"max_compaction_lag_ms,omitempty"`

	// The maximum size, in bytes, of a message.
	MaxMessageBytes *string `json:"maxMessageBytes,omitempty" tf:"max_message_bytes,omitempty"`

	// Determines whether down-conversion of message formats for consumers is enabled.
	MessageDownConversionEnable *bool `json:"messageDownConversionEnable,omitempty" tf:"message_down_conversion_enable,omitempty"`

	// The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
	MessageFormatVersion *string `json:"messageFormatVersion,omitempty" tf:"message_format_version,omitempty"`

	// The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
	MessageTimestampDifferenceMaxMs *string `json:"messageTimestampDifferenceMaxMs,omitempty" tf:"message_timestamp_difference_max_ms,omitempty"`

	// Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
	MessageTimestampType *string `json:"messageTimestampType,omitempty" tf:"message_timestamp_type,omitempty"`

	// A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with max_compaction_lag_ms to control the compactor frequency.
	MinCleanableDirtyRatio *float64 `json:"minCleanableDirtyRatio,omitempty" tf:"min_cleanable_dirty_ratio,omitempty"`

	MinCompactionLagMs *string `json:"minCompactionLagMs,omitempty" tf:"min_compaction_lag_ms,omitempty"`

	// The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
	MinInsyncReplicas *float64 `json:"minInsyncReplicas,omitempty" tf:"min_insync_replicas,omitempty"`

	// Determines whether to preallocate a file on disk when creating a new log segment within a topic.
	Preallocate *bool `json:"preallocate,omitempty" tf:"preallocate,omitempty"`

	// The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
	RetentionBytes *string `json:"retentionBytes,omitempty" tf:"retention_bytes,omitempty"`

	// The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
	RetentionMs *string `json:"retentionMs,omitempty" tf:"retention_ms,omitempty"`

	// The maximum size, in bytes, of a single topic log file.
	SegmentBytes *string `json:"segmentBytes,omitempty" tf:"segment_bytes,omitempty"`

	// The maximum size, in bytes, of the offset index.
	SegmentIndexBytes *string `json:"segmentIndexBytes,omitempty" tf:"segment_index_bytes,omitempty"`

	// The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
	SegmentJitterMs *string `json:"segmentJitterMs,omitempty" tf:"segment_jitter_ms,omitempty"`

	// The maximum time, in ms, before the topic log will flush to disk.
	SegmentMs *string `json:"segmentMs,omitempty" tf:"segment_ms,omitempty"`
}

type ConfigObservation struct {

	// The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
	// This may be one of "delete", "compact", or "compact_delete".
	CleanupPolicy *string `json:"cleanupPolicy,omitempty" tf:"cleanup_policy,omitempty"`

	// The topic compression codecs used for a given topic.
	// This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
	CompressionType *string `json:"compressionType,omitempty" tf:"compression_type,omitempty"`

	// The amount of time, in ms, that deleted records are retained.
	DeleteRetentionMs *string `json:"deleteRetentionMs,omitempty" tf:"delete_retention_ms,omitempty"`

	// The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
	FileDeleteDelayMs *string `json:"fileDeleteDelayMs,omitempty" tf:"file_delete_delay_ms,omitempty"`

	// The number of messages accumulated on a topic partition before they are flushed to disk.
	FlushMessages *string `json:"flushMessages,omitempty" tf:"flush_messages,omitempty"`

	// The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
	FlushMs *string `json:"flushMs,omitempty" tf:"flush_ms,omitempty"`

	// The interval, in bytes, in which entries are added to the offset index.
	IndexIntervalBytes *string `json:"indexIntervalBytes,omitempty" tf:"index_interval_bytes,omitempty"`

	// The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the compression_type is set to "uncompressed" or it is set to producer and the producer is not using compression.
	MaxCompactionLagMs *string `json:"maxCompactionLagMs,omitempty" tf:"max_compaction_lag_ms,omitempty"`

	// The maximum size, in bytes, of a message.
	MaxMessageBytes *string `json:"maxMessageBytes,omitempty" tf:"max_message_bytes,omitempty"`

	// Determines whether down-conversion of message formats for consumers is enabled.
	MessageDownConversionEnable *bool `json:"messageDownConversionEnable,omitempty" tf:"message_down_conversion_enable,omitempty"`

	// The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
	MessageFormatVersion *string `json:"messageFormatVersion,omitempty" tf:"message_format_version,omitempty"`

	// The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
	MessageTimestampDifferenceMaxMs *string `json:"messageTimestampDifferenceMaxMs,omitempty" tf:"message_timestamp_difference_max_ms,omitempty"`

	// Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
	MessageTimestampType *string `json:"messageTimestampType,omitempty" tf:"message_timestamp_type,omitempty"`

	// A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with max_compaction_lag_ms to control the compactor frequency.
	MinCleanableDirtyRatio *float64 `json:"minCleanableDirtyRatio,omitempty" tf:"min_cleanable_dirty_ratio,omitempty"`

	MinCompactionLagMs *string `json:"minCompactionLagMs,omitempty" tf:"min_compaction_lag_ms,omitempty"`

	// The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
	MinInsyncReplicas *float64 `json:"minInsyncReplicas,omitempty" tf:"min_insync_replicas,omitempty"`

	// Determines whether to preallocate a file on disk when creating a new log segment within a topic.
	Preallocate *bool `json:"preallocate,omitempty" tf:"preallocate,omitempty"`

	// The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
	RetentionBytes *string `json:"retentionBytes,omitempty" tf:"retention_bytes,omitempty"`

	// The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
	RetentionMs *string `json:"retentionMs,omitempty" tf:"retention_ms,omitempty"`

	// The maximum size, in bytes, of a single topic log file.
	SegmentBytes *string `json:"segmentBytes,omitempty" tf:"segment_bytes,omitempty"`

	// The maximum size, in bytes, of the offset index.
	SegmentIndexBytes *string `json:"segmentIndexBytes,omitempty" tf:"segment_index_bytes,omitempty"`

	// The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
	SegmentJitterMs *string `json:"segmentJitterMs,omitempty" tf:"segment_jitter_ms,omitempty"`

	// The maximum time, in ms, before the topic log will flush to disk.
	SegmentMs *string `json:"segmentMs,omitempty" tf:"segment_ms,omitempty"`
}

type ConfigParameters struct {

	// The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
	// This may be one of "delete", "compact", or "compact_delete".
	// +kubebuilder:validation:Optional
	CleanupPolicy *string `json:"cleanupPolicy,omitempty" tf:"cleanup_policy,omitempty"`

	// The topic compression codecs used for a given topic.
	// This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
	// +kubebuilder:validation:Optional
	CompressionType *string `json:"compressionType,omitempty" tf:"compression_type,omitempty"`

	// The amount of time, in ms, that deleted records are retained.
	// +kubebuilder:validation:Optional
	DeleteRetentionMs *string `json:"deleteRetentionMs,omitempty" tf:"delete_retention_ms,omitempty"`

	// The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
	// +kubebuilder:validation:Optional
	FileDeleteDelayMs *string `json:"fileDeleteDelayMs,omitempty" tf:"file_delete_delay_ms,omitempty"`

	// The number of messages accumulated on a topic partition before they are flushed to disk.
	// +kubebuilder:validation:Optional
	FlushMessages *string `json:"flushMessages,omitempty" tf:"flush_messages,omitempty"`

	// The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
	// +kubebuilder:validation:Optional
	FlushMs *string `json:"flushMs,omitempty" tf:"flush_ms,omitempty"`

	// The interval, in bytes, in which entries are added to the offset index.
	// +kubebuilder:validation:Optional
	IndexIntervalBytes *string `json:"indexIntervalBytes,omitempty" tf:"index_interval_bytes,omitempty"`

	// The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the compression_type is set to "uncompressed" or it is set to producer and the producer is not using compression.
	// +kubebuilder:validation:Optional
	MaxCompactionLagMs *string `json:"maxCompactionLagMs,omitempty" tf:"max_compaction_lag_ms,omitempty"`

	// The maximum size, in bytes, of a message.
	// +kubebuilder:validation:Optional
	MaxMessageBytes *string `json:"maxMessageBytes,omitempty" tf:"max_message_bytes,omitempty"`

	// Determines whether down-conversion of message formats for consumers is enabled.
	// +kubebuilder:validation:Optional
	MessageDownConversionEnable *bool `json:"messageDownConversionEnable,omitempty" tf:"message_down_conversion_enable,omitempty"`

	// The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
	// +kubebuilder:validation:Optional
	MessageFormatVersion *string `json:"messageFormatVersion,omitempty" tf:"message_format_version,omitempty"`

	// The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
	// +kubebuilder:validation:Optional
	MessageTimestampDifferenceMaxMs *string `json:"messageTimestampDifferenceMaxMs,omitempty" tf:"message_timestamp_difference_max_ms,omitempty"`

	// Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
	// +kubebuilder:validation:Optional
	MessageTimestampType *string `json:"messageTimestampType,omitempty" tf:"message_timestamp_type,omitempty"`

	// A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with max_compaction_lag_ms to control the compactor frequency.
	// +kubebuilder:validation:Optional
	MinCleanableDirtyRatio *float64 `json:"minCleanableDirtyRatio,omitempty" tf:"min_cleanable_dirty_ratio,omitempty"`

	// +kubebuilder:validation:Optional
	MinCompactionLagMs *string `json:"minCompactionLagMs,omitempty" tf:"min_compaction_lag_ms,omitempty"`

	// The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
	// +kubebuilder:validation:Optional
	MinInsyncReplicas *float64 `json:"minInsyncReplicas,omitempty" tf:"min_insync_replicas,omitempty"`

	// Determines whether to preallocate a file on disk when creating a new log segment within a topic.
	// +kubebuilder:validation:Optional
	Preallocate *bool `json:"preallocate,omitempty" tf:"preallocate,omitempty"`

	// The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
	// +kubebuilder:validation:Optional
	RetentionBytes *string `json:"retentionBytes,omitempty" tf:"retention_bytes,omitempty"`

	// The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
	// +kubebuilder:validation:Optional
	RetentionMs *string `json:"retentionMs,omitempty" tf:"retention_ms,omitempty"`

	// The maximum size, in bytes, of a single topic log file.
	// +kubebuilder:validation:Optional
	SegmentBytes *string `json:"segmentBytes,omitempty" tf:"segment_bytes,omitempty"`

	// The maximum size, in bytes, of the offset index.
	// +kubebuilder:validation:Optional
	SegmentIndexBytes *string `json:"segmentIndexBytes,omitempty" tf:"segment_index_bytes,omitempty"`

	// The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
	// +kubebuilder:validation:Optional
	SegmentJitterMs *string `json:"segmentJitterMs,omitempty" tf:"segment_jitter_ms,omitempty"`

	// The maximum time, in ms, before the topic log will flush to disk.
	// +kubebuilder:validation:Optional
	SegmentMs *string `json:"segmentMs,omitempty" tf:"segment_ms,omitempty"`
}

type KafkaTopicInitParameters struct {

	// The ID of the source database cluster. Note: This must be a Kafka cluster.
	// +crossplane:generate:reference:type=Cluster
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
	// The config block is documented below.
	Config []ConfigInitParameters `json:"config,omitempty" tf:"config,omitempty"`

	// The name for the topic.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`
}

type KafkaTopicObservation struct {

	// The ID of the source database cluster. Note: This must be a Kafka cluster.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
	// The config block is documented below.
	Config []ConfigObservation `json:"config,omitempty" tf:"config,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The name for the topic.
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`

	// The current status of the topic. Possible values are 'active', 'configuring', and 'deleting'.
	State *string `json:"state,omitempty" tf:"state,omitempty"`
}

type KafkaTopicParameters struct {

	// The ID of the source database cluster. Note: This must be a Kafka cluster.
	// +crossplane:generate:reference:type=Cluster
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// A set of advanced configuration parameters. Defaults will be set for any of the parameters that are not included.
	// The config block is documented below.
	// +kubebuilder:validation:Optional
	Config []ConfigParameters `json:"config,omitempty" tf:"config,omitempty"`

	// The name for the topic.
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// The number of partitions for the topic. Default and minimum set at 3, maximum is 2048.
	// +kubebuilder:validation:Optional
	PartitionCount *float64 `json:"partitionCount,omitempty" tf:"partition_count,omitempty"`

	// The number of nodes that topics are replicated across. Default and minimum set at 2, maximum is the number of nodes in the cluster.
	// +kubebuilder:validation:Optional
	ReplicationFactor *float64 `json:"replicationFactor,omitempty" tf:"replication_factor,omitempty"`
}

// KafkaTopicSpec defines the desired state of KafkaTopic
type KafkaTopicSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     KafkaTopicParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider KafkaTopicInitParameters `json:"initProvider,omitempty"`
}

// KafkaTopicStatus defines the observed state of KafkaTopic.
type KafkaTopicStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        KafkaTopicObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// KafkaTopic is the Schema for the KafkaTopics API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,do}
type KafkaTopic struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	Spec   KafkaTopicSpec   `json:"spec"`
	Status KafkaTopicStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// KafkaTopicList contains a list of KafkaTopics
type KafkaTopicList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []KafkaTopic `json:"items"`
}

// Repository type metadata.
var (
	KafkaTopic_Kind             = "KafkaTopic"
	KafkaTopic_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: KafkaTopic_Kind}.String()
	KafkaTopic_KindAPIVersion   = KafkaTopic_Kind + "." + CRDGroupVersion.String()
	KafkaTopic_GroupVersionKind = CRDGroupVersion.WithKind(KafkaTopic_Kind)
)

func init() {
	SchemeBuilder.Register(&KafkaTopic{}, &KafkaTopicList{})
}
