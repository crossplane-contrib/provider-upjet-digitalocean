/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type RedisConfigInitParameters struct {

	// Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
	ACLChannelsDefault *string `json:"aclChannelsDefault,omitempty" tf:"acl_channels_default,omitempty"`

	// The ID of the target Redis cluster.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-digitalocean/apis/database/v1alpha1.Cluster
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster in database to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster in database to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// The Redis IO thread count.
	IoThreads *float64 `json:"ioThreads,omitempty" tf:"io_threads,omitempty"`

	// The LFU maxmemory policy counter decay time in minutes.
	LfuDecayTime *float64 `json:"lfuDecayTime,omitempty" tf:"lfu_decay_time,omitempty"`

	// The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
	LfuLogFactor *float64 `json:"lfuLogFactor,omitempty" tf:"lfu_log_factor,omitempty"`

	// A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
	MaxmemoryPolicy *string `json:"maxmemoryPolicy,omitempty" tf:"maxmemory_policy,omitempty"`

	// The notify-keyspace-events option. Requires at least K or E.
	NotifyKeyspaceEvents *string `json:"notifyKeyspaceEvents,omitempty" tf:"notify_keyspace_events,omitempty"`

	// The number of Redis databases. Changing this will cause a restart of Redis service.
	NumberOfDatabases *float64 `json:"numberOfDatabases,omitempty" tf:"number_of_databases,omitempty"`

	// When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
	Persistence *string `json:"persistence,omitempty" tf:"persistence,omitempty"`

	// The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
	PubsubClientOutputBufferLimit *float64 `json:"pubsubClientOutputBufferLimit,omitempty" tf:"pubsub_client_output_buffer_limit,omitempty"`

	// A boolean indicating whether to require SSL to access Redis.
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Redis idle connection timeout in seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type RedisConfigObservation struct {

	// Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
	ACLChannelsDefault *string `json:"aclChannelsDefault,omitempty" tf:"acl_channels_default,omitempty"`

	// The ID of the target Redis cluster.
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// The Redis IO thread count.
	IoThreads *float64 `json:"ioThreads,omitempty" tf:"io_threads,omitempty"`

	// The LFU maxmemory policy counter decay time in minutes.
	LfuDecayTime *float64 `json:"lfuDecayTime,omitempty" tf:"lfu_decay_time,omitempty"`

	// The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
	LfuLogFactor *float64 `json:"lfuLogFactor,omitempty" tf:"lfu_log_factor,omitempty"`

	// A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
	MaxmemoryPolicy *string `json:"maxmemoryPolicy,omitempty" tf:"maxmemory_policy,omitempty"`

	// The notify-keyspace-events option. Requires at least K or E.
	NotifyKeyspaceEvents *string `json:"notifyKeyspaceEvents,omitempty" tf:"notify_keyspace_events,omitempty"`

	// The number of Redis databases. Changing this will cause a restart of Redis service.
	NumberOfDatabases *float64 `json:"numberOfDatabases,omitempty" tf:"number_of_databases,omitempty"`

	// When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
	Persistence *string `json:"persistence,omitempty" tf:"persistence,omitempty"`

	// The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
	PubsubClientOutputBufferLimit *float64 `json:"pubsubClientOutputBufferLimit,omitempty" tf:"pubsub_client_output_buffer_limit,omitempty"`

	// A boolean indicating whether to require SSL to access Redis.
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Redis idle connection timeout in seconds.
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type RedisConfigParameters struct {

	// Determines default pub/sub channels' ACL for new users if an ACL is not supplied. When this option is not defined, allchannels is assumed to keep backward compatibility. This option doesn't affect Redis' acl-pubsub-default configuration. Supported values are: allchannels and resetchannels
	// +kubebuilder:validation:Optional
	ACLChannelsDefault *string `json:"aclChannelsDefault,omitempty" tf:"acl_channels_default,omitempty"`

	// The ID of the target Redis cluster.
	// +crossplane:generate:reference:type=github.com/crossplane-contrib/provider-upjet-digitalocean/apis/database/v1alpha1.Cluster
	// +kubebuilder:validation:Optional
	ClusterID *string `json:"clusterId,omitempty" tf:"cluster_id,omitempty"`

	// Reference to a Cluster in database to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDRef *v1.Reference `json:"clusterIdRef,omitempty" tf:"-"`

	// Selector for a Cluster in database to populate clusterId.
	// +kubebuilder:validation:Optional
	ClusterIDSelector *v1.Selector `json:"clusterIdSelector,omitempty" tf:"-"`

	// The Redis IO thread count.
	// +kubebuilder:validation:Optional
	IoThreads *float64 `json:"ioThreads,omitempty" tf:"io_threads,omitempty"`

	// The LFU maxmemory policy counter decay time in minutes.
	// +kubebuilder:validation:Optional
	LfuDecayTime *float64 `json:"lfuDecayTime,omitempty" tf:"lfu_decay_time,omitempty"`

	// The counter logarithm factor for volatile-lfu and allkeys-lfu maxmemory policies.
	// +kubebuilder:validation:Optional
	LfuLogFactor *float64 `json:"lfuLogFactor,omitempty" tf:"lfu_log_factor,omitempty"`

	// A string specifying the desired eviction policy for the Redis cluster.Supported values are: noeviction, allkeys-lru, allkeys-random, volatile-lru, volatile-random, volatile-ttl
	// +kubebuilder:validation:Optional
	MaxmemoryPolicy *string `json:"maxmemoryPolicy,omitempty" tf:"maxmemory_policy,omitempty"`

	// The notify-keyspace-events option. Requires at least K or E.
	// +kubebuilder:validation:Optional
	NotifyKeyspaceEvents *string `json:"notifyKeyspaceEvents,omitempty" tf:"notify_keyspace_events,omitempty"`

	// The number of Redis databases. Changing this will cause a restart of Redis service.
	// +kubebuilder:validation:Optional
	NumberOfDatabases *float64 `json:"numberOfDatabases,omitempty" tf:"number_of_databases,omitempty"`

	// When persistence is rdb, Redis does RDB dumps each 10 minutes if any key is changed. Also RDB dumps are done according to backup schedule for backup purposes. When persistence is off, no RDB dumps and backups are done, so data can be lost at any moment if service is restarted for any reason, or if service is powered off. Also service can't be forked.
	// +kubebuilder:validation:Optional
	Persistence *string `json:"persistence,omitempty" tf:"persistence,omitempty"`

	// The output buffer limit for pub/sub clients in MB. The value is the hard limit, the soft limit is 1/4 of the hard limit. When setting the limit, be mindful of the available memory in the selected service plan.
	// +kubebuilder:validation:Optional
	PubsubClientOutputBufferLimit *float64 `json:"pubsubClientOutputBufferLimit,omitempty" tf:"pubsub_client_output_buffer_limit,omitempty"`

	// A boolean indicating whether to require SSL to access Redis.
	// +kubebuilder:validation:Optional
	SSL *bool `json:"ssl,omitempty" tf:"ssl,omitempty"`

	// The Redis idle connection timeout in seconds.
	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

// RedisConfigSpec defines the desired state of RedisConfig
type RedisConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RedisConfigParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider RedisConfigInitParameters `json:"initProvider,omitempty"`
}

// RedisConfigStatus defines the observed state of RedisConfig.
type RedisConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RedisConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// RedisConfig is the Schema for the RedisConfigs API.
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,do}
type RedisConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RedisConfigSpec   `json:"spec"`
	Status            RedisConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RedisConfigList contains a list of RedisConfigs
type RedisConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RedisConfig `json:"items"`
}

// Repository type metadata.
var (
	RedisConfig_Kind             = "RedisConfig"
	RedisConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: RedisConfig_Kind}.String()
	RedisConfig_KindAPIVersion   = RedisConfig_Kind + "." + CRDGroupVersion.String()
	RedisConfig_GroupVersionKind = CRDGroupVersion.WithKind(RedisConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&RedisConfig{}, &RedisConfigList{})
}
